define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.FileSystemBrokerSingleton = _exports.FileSystemBroker = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * Copyright 2021 The Pennsylvania State University
   * @license Apache-2.0, see License.md for full text.
   */

  /**
   * `file-system-broker`
   * `singleton to simplify interactions with the file system on a user&#39;s device`
   *
   * @demo demo/index.html Demo
   * @demo demo/xlsx.html XLSX loader
   * @element file-system-broker
   */
  var FileSystemBroker = /*#__PURE__*/function (_HTMLElement) {
    babelHelpers.inherits(FileSystemBroker, _HTMLElement);

    var _super = _createSuper(FileSystemBroker);

    /**
     * object life cycle
     */
    function FileSystemBroker() {
      var _this;

      babelHelpers.classCallCheck(this, FileSystemBroker);
      _this = _super.call(this);
      _this.dirHandler = null;
      _this.fileHandler = null;
      _this.files = [];
      return _this;
    }
    /**
     * This is a convention, not the standard
     */


    babelHelpers.createClass(FileSystemBroker, [{
      key: "loadFile",
      value:
      /**
       * Get contents of a file based on type
       * @param {String} type
       * @param {Boolean} multiple
       * @param {Boolean} excludeAll
       * @returns
       */
      function () {
        var _loadFile = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(type) {
          var multiple,
              excludeAll,
              accept,
              fileHandle,
              description,
              _yield$window$showOpe,
              _yield$window$showOpe2,
              _args = arguments;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  multiple = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;
                  excludeAll = _args.length > 2 && _args[2] !== undefined ? _args[2] : true;
                  accept = this.typeToAccept(type);
                  description = "".concat(type, " file");
                  _context.next = 6;
                  return window.showOpenFilePicker({
                    types: [{
                      description: description,
                      accept: accept
                    }],
                    excludeAcceptAllOption: excludeAll,
                    multiple: multiple
                  });

                case 6:
                  _yield$window$showOpe = _context.sent;
                  _yield$window$showOpe2 = babelHelpers.slicedToArray(_yield$window$showOpe, 1);
                  fileHandle = _yield$window$showOpe2[0];
                  _context.next = 11;
                  return fileHandle.getFile();

                case 11:
                  this.fileHandler = _context.sent;
                  return _context.abrupt("return", this.fileHandler);

                case 13:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function loadFile(_x) {
          return _loadFile.apply(this, arguments);
        }

        return loadFile;
      }()
      /**
       * Get contents of a file based on type
       * @param {String} type
       * @param {Boolean} multiple
       * @param {Boolean} excludeAll
       * @returns
       */

    }, {
      key: "getFileContents",
      value: function () {
        var _getFileContents = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(type) {
          var multiple,
              excludeAll,
              _args2 = arguments;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  multiple = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : false;
                  excludeAll = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : true;
                  _context2.next = 4;
                  return this.loadFile(type, multiple, excludeAll);

                case 4:
                  _context2.next = 6;
                  return this.fileHandler.text();

                case 6:
                  return _context2.abrupt("return", _context2.sent);

                case 7:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function getFileContents(_x2) {
          return _getFileContents.apply(this, arguments);
        }

        return getFileContents;
      }()
    }, {
      key: "typeToAccept",
      value: function typeToAccept(type) {
        var accept = {};

        switch (type) {
          case "xls":
          case "xlsx":
          case "ods":
            accept = {
              "text/csv": [".csv"],
              "application/*": [".xls", ".xlsx", ".ods"]
            };
            break;

          case "csv":
            accept = {
              "text/*": [".csv", ".txt"]
            };
            break;

          case "image":
            accept = {
              "image/*": [".jpg", ".jpeg", ".gif", ".png"]
            };
            break;

          case "video":
            accept = {
              "video/*": [".mp4"]
            };
            break;

          case "markdown":
            accept = {
              "text/*": [".txt", ".md"]
            };
            break;
        }

        return accept;
      }
    }, {
      key: "saveFile",
      value: function () {
        var _saveFile = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(type, content) {
          var accept, description, options, writable;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  accept = this.typeToAccept(type);
                  description = "Save ".concat(type, " file");
                  options = {
                    types: [{
                      description: description,
                      accept: accept
                    }]
                  };
                  _context3.next = 5;
                  return window.showSaveFilePicker(options);

                case 5:
                  this.fileHandler = _context3.sent;
                  _context3.next = 8;
                  return this.fileHandler.createWritable();

                case 8:
                  writable = _context3.sent;
                  _context3.next = 11;
                  return writable.write(content);

                case 11:
                  _context3.next = 13;
                  return writable.close();

                case 13:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function saveFile(_x3, _x4) {
          return _saveFile.apply(this, arguments);
        }

        return saveFile;
      }()
      /**
       * Open directory
       */

    }, {
      key: "openDir",
      value: function () {
        var _openDir = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
          var recursive,
              _args4 = arguments;
          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  recursive = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : true;
                  _context4.prev = 1;
                  _context4.next = 4;
                  return window.showDirectoryPicker();

                case 4:
                  this.dirHandler = _context4.sent;
                  _context4.next = 10;
                  break;

                case 7:
                  _context4.prev = 7;
                  _context4.t0 = _context4["catch"](1);
                  console.log(_context4.t0);

                case 10:
                  this.files = [];
                  _context4.next = 13;
                  return this.__readDir(this.dirHandler, recursive, this.dirHandler.name + "/", this.dirHandler);

                case 13:
                  this.files = _context4.sent;
                  return _context4.abrupt("return", this.files);

                case 15:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this, [[1, 7]]);
        }));

        function openDir() {
          return _openDir.apply(this, arguments);
        }

        return openDir;
      }()
    }, {
      key: "readFileInDir",
      value: function () {
        var _readFileInDir = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(fileName) {
          var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, entry, file;

          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.prev = 0;
                  _context5.next = 3;
                  return window.showDirectoryPicker();

                case 3:
                  this.dirHandler = _context5.sent;
                  // need to load references found in the directory
                  _iteratorNormalCompletion = true;
                  _didIteratorError = false;
                  _context5.prev = 6;
                  _iterator = babelHelpers.asyncIterator(this.dirHandler.values());

                case 8:
                  _context5.next = 10;
                  return _iterator.next();

                case 10:
                  _step = _context5.sent;
                  _iteratorNormalCompletion = _step.done;
                  _context5.next = 14;
                  return _step.value;

                case 14:
                  _value = _context5.sent;

                  if (_iteratorNormalCompletion) {
                    _context5.next = 27;
                    break;
                  }

                  entry = _value;

                  if (!(fileName && typeof entry.getFile === "function" && entry.name === fileName)) {
                    _context5.next = 24;
                    break;
                  }

                  _context5.next = 20;
                  return entry.getFile();

                case 20:
                  file = _context5.sent;
                  _context5.next = 23;
                  return file.text();

                case 23:
                  return _context5.abrupt("return", _context5.sent);

                case 24:
                  _iteratorNormalCompletion = true;
                  _context5.next = 8;
                  break;

                case 27:
                  _context5.next = 33;
                  break;

                case 29:
                  _context5.prev = 29;
                  _context5.t0 = _context5["catch"](6);
                  _didIteratorError = true;
                  _iteratorError = _context5.t0;

                case 33:
                  _context5.prev = 33;
                  _context5.prev = 34;

                  if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
                    _context5.next = 38;
                    break;
                  }

                  _context5.next = 38;
                  return _iterator.return();

                case 38:
                  _context5.prev = 38;

                  if (!_didIteratorError) {
                    _context5.next = 41;
                    break;
                  }

                  throw _iteratorError;

                case 41:
                  return _context5.finish(38);

                case 42:
                  return _context5.finish(33);

                case 43:
                  _context5.next = 48;
                  break;

                case 45:
                  _context5.prev = 45;
                  _context5.t1 = _context5["catch"](0);
                  console.log(_context5.t1);

                case 48:
                  return _context5.abrupt("return", "");

                case 49:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this, [[0, 45], [6, 29, 33, 43], [34,, 38, 42]]);
        }));

        function readFileInDir(_x5) {
          return _readFileInDir.apply(this, arguments);
        }

        return readFileInDir;
      }()
    }, {
      key: "writeFileInDir",
      value: function () {
        var _writeFileInDir = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(fileName) {
          var content,
              _iteratorNormalCompletion2,
              _didIteratorError2,
              _iteratorError2,
              _iterator2,
              _step2,
              _value2,
              entry,
              FileSystemFileHandle,
              writable,
              _args6 = arguments;

          return regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  content = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : "";
                  _context6.prev = 1;
                  _context6.next = 4;
                  return window.showDirectoryPicker();

                case 4:
                  this.dirHandler = _context6.sent;
                  // need to load references found in the directory
                  _iteratorNormalCompletion2 = true;
                  _didIteratorError2 = false;
                  _context6.prev = 7;
                  _iterator2 = babelHelpers.asyncIterator(this.dirHandler.values());

                case 9:
                  _context6.next = 11;
                  return _iterator2.next();

                case 11:
                  _step2 = _context6.sent;
                  _iteratorNormalCompletion2 = _step2.done;
                  _context6.next = 15;
                  return _step2.value;

                case 15:
                  _value2 = _context6.sent;

                  if (_iteratorNormalCompletion2) {
                    _context6.next = 33;
                    break;
                  }

                  entry = _value2;

                  if (!(fileName && typeof entry.getFile === "function" && entry.name === fileName)) {
                    _context6.next = 30;
                    break;
                  }

                  _context6.next = 21;
                  return this.dirHandler.getFileHandle(entry.name);

                case 21:
                  FileSystemFileHandle = _context6.sent;
                  _context6.next = 24;
                  return FileSystemFileHandle.createWritable();

                case 24:
                  writable = _context6.sent;
                  _context6.next = 27;
                  return writable.write(content);

                case 27:
                  _context6.next = 29;
                  return writable.close();

                case 29:
                  return _context6.abrupt("return", true);

                case 30:
                  _iteratorNormalCompletion2 = true;
                  _context6.next = 9;
                  break;

                case 33:
                  _context6.next = 39;
                  break;

                case 35:
                  _context6.prev = 35;
                  _context6.t0 = _context6["catch"](7);
                  _didIteratorError2 = true;
                  _iteratorError2 = _context6.t0;

                case 39:
                  _context6.prev = 39;
                  _context6.prev = 40;

                  if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {
                    _context6.next = 44;
                    break;
                  }

                  _context6.next = 44;
                  return _iterator2.return();

                case 44:
                  _context6.prev = 44;

                  if (!_didIteratorError2) {
                    _context6.next = 47;
                    break;
                  }

                  throw _iteratorError2;

                case 47:
                  return _context6.finish(44);

                case 48:
                  return _context6.finish(39);

                case 49:
                  _context6.next = 54;
                  break;

                case 51:
                  _context6.prev = 51;
                  _context6.t1 = _context6["catch"](1);
                  console.log(_context6.t1);

                case 54:
                  return _context6.abrupt("return", false);

                case 55:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this, [[1, 51], [7, 35, 39, 49], [40,, 44, 48]]);
        }));

        function writeFileInDir(_x6) {
          return _writeFileInDir.apply(this, arguments);
        }

        return writeFileInDir;
      }()
      /**
       * Read contents of a directory and recursively load down from there
       */

    }, {
      key: "__readDir",
      value: function () {
        var _readDir = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(dirHandle, recursive, folder, parentHandler) {
          var files, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _value3, _value4, _value5, name, handle, kind;

          return regeneratorRuntime.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  files = [];
                  _iteratorNormalCompletion3 = true;
                  _didIteratorError3 = false;
                  _context7.prev = 3;
                  _iterator3 = babelHelpers.asyncIterator(dirHandle);

                case 5:
                  _context7.next = 7;
                  return _iterator3.next();

                case 7:
                  _step3 = _context7.sent;
                  _iteratorNormalCompletion3 = _step3.done;
                  _context7.next = 11;
                  return _step3.value;

                case 11:
                  _value3 = _context7.sent;

                  if (_iteratorNormalCompletion3) {
                    _context7.next = 32;
                    break;
                  }

                  _value4 = _value3, _value5 = babelHelpers.slicedToArray(_value4, 2), name = _value5[0], handle = _value5[1];
                  kind = handle.kind;

                  if (!(handle.kind === "directory")) {
                    _context7.next = 28;
                    break;
                  }

                  files.push({
                    name: name,
                    kind: kind,
                    handle: handle,
                    folder: folder,
                    parentHandler: parentHandler
                  });

                  if (!(name !== ".git" && recursive)) {
                    _context7.next = 26;
                    break;
                  }

                  _context7.t0 = files.push;
                  _context7.t1 = files;
                  _context7.t2 = babelHelpers;
                  _context7.next = 23;
                  return this.__readDir(handle, recursive, folder + name + "/", handle);

                case 23:
                  _context7.t3 = _context7.sent;
                  _context7.t4 = _context7.t2.toConsumableArray.call(_context7.t2, _context7.t3);

                  _context7.t0.apply.call(_context7.t0, _context7.t1, _context7.t4);

                case 26:
                  _context7.next = 29;
                  break;

                case 28:
                  files.push({
                    name: name,
                    kind: kind,
                    handle: handle,
                    folder: folder,
                    parentHandler: parentHandler
                  });

                case 29:
                  _iteratorNormalCompletion3 = true;
                  _context7.next = 5;
                  break;

                case 32:
                  _context7.next = 38;
                  break;

                case 34:
                  _context7.prev = 34;
                  _context7.t5 = _context7["catch"](3);
                  _didIteratorError3 = true;
                  _iteratorError3 = _context7.t5;

                case 38:
                  _context7.prev = 38;
                  _context7.prev = 39;

                  if (!(!_iteratorNormalCompletion3 && _iterator3.return != null)) {
                    _context7.next = 43;
                    break;
                  }

                  _context7.next = 43;
                  return _iterator3.return();

                case 43:
                  _context7.prev = 43;

                  if (!_didIteratorError3) {
                    _context7.next = 46;
                    break;
                  }

                  throw _iteratorError3;

                case 46:
                  return _context7.finish(43);

                case 47:
                  return _context7.finish(38);

                case 48:
                  return _context7.abrupt("return", files);

                case 49:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this, [[3, 34, 38, 48], [39,, 43, 47]]);
        }));

        function __readDir(_x7, _x8, _x9, _x10) {
          return _readDir.apply(this, arguments);
        }

        return __readDir;
      }()
    }], [{
      key: "tag",
      get: function get() {
        return "file-system-broker";
      }
    }]);
    return FileSystemBroker;
  }( /*#__PURE__*/babelHelpers.wrapNativeSuper(HTMLElement)); // register globally so we can make sure there is only one


  _exports.FileSystemBroker = FileSystemBroker;
  window.FileSystemBroker = window.FileSystemBroker || {};

  window.FileSystemBroker.requestAvailability = function () {
    // if there is no single instance, generate one and append it to end of the document
    if (!window.FileSystemBroker.instance) {
      window.FileSystemBroker.instance = document.createElement("file-system-broker");
      document.body.appendChild(window.FileSystemBroker.instance);
    }

    return window.FileSystemBroker.instance;
  }; // forces appending


  var FileSystemBrokerSingleton = window.FileSystemBroker.requestAvailability();
  _exports.FileSystemBrokerSingleton = FileSystemBrokerSingleton;
  customElements.define(FileSystemBroker.tag, FileSystemBroker);
});