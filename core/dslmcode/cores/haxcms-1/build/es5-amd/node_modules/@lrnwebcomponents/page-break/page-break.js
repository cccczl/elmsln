define(["exports", "meta", "../../lit/index.js", "../schema-behaviors/schema-behaviors.js", "../intersection-element/lib/IntersectionObserverMixin.js", "../i18n-manager/lib/I18NMixin.js", "../simple-icon/simple-icon.js", "./lib/page-break-manager.js", "../simple-icon/lib/simple-icons.js", "../simple-icon/lib/simple-iconset.js"], function (_exports, meta, _index, _schemaBehaviors, _IntersectionObserverMixin, _I18NMixin, _simpleIcon, _pageBreakManager, _simpleIcons, _simpleIconset) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.PageBreak = void 0;
  meta = _interopRequireWildcard(meta);

  var _templateObject_941826b0374311ecbe28b7086a8f3f78, _templateObject2_941826b0374311ecbe28b7086a8f3f78;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var PageBreak = /*#__PURE__*/function (_IntersectionObserver) {
    babelHelpers.inherits(PageBreak, _IntersectionObserver);

    var _super = _createSuper(PageBreak);

    function PageBreak() {
      var _this;

      babelHelpers.classCallCheck(this, PageBreak);
      _this = _super.call(this);
      _this.t = {
        newPage: "New page",
        pageBreak: "Page break",
        pageDetails: "Page details"
      };
      _this.title = _this.t.newPage;
      _this.path = "#";
      _this.published = true;
      _this.lock = false;
      _this.target = null;
      _this.depth = 0;
      _this.itemId = null;
      _this._haxState = false;
      _this.IORemoveOnVisible = false;
      _this.IODelay = 250;
      _this.remoteHeadingobserver = new MutationObserver(function () {
        // lock ensures that title update, then updating hte innerText
        // doesn't generate another mutation record
        if (_this.title != _this.target.innerText) {
          _this.__moUpdate = true;
          _this.title = _this.target.innerText;
        }
      }); // default break type for the vast majority of situations

      _this.breakType = "node";
      return _this;
    }

    babelHelpers.createClass(PageBreak, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        var _this2 = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak.prototype), "connectedCallback", this).call(this);

        if (this.breakType === "node") {
          if (this.nextElementSibling && this.nextElementSibling.tagName && ["H1", "H2", "H3", "H4", "H5", "H6"].includes(this.nextElementSibling.tagName)) {
            this.title = this.nextElementSibling.innerText;
            this.target = this.nextElementSibling;
            this.setupTargetData(this.target);
          } else {
            // we are going to inject a title element possibly so pause
            // to make sure there wasn't some timing in rendering before
            // we accidentally inject an element
            setTimeout(function () {
              if (_this2.target === null) {
                if (_this2.nextElementSibling && _this2.nextElementSibling.tagName && ["H1", "H2", "H3", "H4", "H5", "H6"].includes(_this2.nextElementSibling.tagName)) {
                  _this2.title = _this2.nextElementSibling.innerText;
                  _this2.target = _this2.nextElementSibling;

                  _this2.setupTargetData(_this2.target);
                } else {
                  var tagName = _this2.depth === 0 ? "h2" : "h".concat(_this2.depth + 2);
                  var newH = document.createElement(tagName);
                  newH.setAttribute("data-original-level", "H2");
                  newH.innerText = _this2.title;

                  _this2.parentNode.insertBefore(newH, _this2.nextElementSibling); // account for HAX which might mess w/ the tag on insert


                  setTimeout(function () {
                    _this2.setupTargetData(_this2.nextElementSibling);
                  }, 100);
                }
              }
            }, 0);
          }
        }

        window.dispatchEvent(new CustomEvent("page-break-registration", {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            value: this,
            action: "add"
          }
        }));
        window.dispatchEvent(new CustomEvent("page-break-change", {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            value: this
          }
        }));
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.dispatchEvent(new CustomEvent("page-break-registration", {
          detail: {
            value: this,
            action: "remove"
          }
        }));
        window.dispatchEvent(new CustomEvent("page-break-change", {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            value: this
          }
        }));
        this.remoteHeadingobserver.disconnect();
        babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak.prototype), "disconnectedCallback", this).call(this);
      } // setup the target data

    }, {
      key: "setupTargetData",
      value: function setupTargetData(newTarget) {
        if (this.target) {
          this.remoteHeadingobserver.disconnect();
        }

        this.target = newTarget; // add a backdoor for hax to have a hook into this

        this._haxSibling = this; // @todo need to add some kind of "if this gets deleted let me know"
        // or a hook that basically blocks this being deleted because it
        // is under control of the page-break tag

        this.remoteHeadingobserver.observe(this.target, {
          characterData: true,
          childList: true,
          subtree: true
        });
      }
    }, {
      key: "updated",
      value: function updated(changedProperties) {
        var _this3 = this;

        if (babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak.prototype), "updated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak.prototype), "updated", this).call(this, changedProperties);
        }

        changedProperties.forEach(function (oldValue, propName) {
          // align schema ID w/ the ID from itemId
          if (propName === "itemId" && _this3[propName] != null) {
            _this3.schemaResourceID = _this3.itemId;
          } else if (propName === "schemaResourceID" && _this3.itemId == null) {
            _this3.itemId = _this3.schemaResourceID.replace("#", "");
          } // when visible, "click" the thing so that it's activated


          if (propName === "elementVisible" && _this3.elementVisible && _this3.itemId && _this3.shadowRoot) {
            setTimeout(function () {
              _pageBreakManager.pageBreakManager.updateVisibleAsActive();
            }, 0);
          } // replicate lock status


          if (_this3.lock && propName === "lock") {
            _pageBreakManager.pageBreakManager.elementsBetween(_this3).forEach(function (el) {
              el.setAttribute("data-hax-lock", "data-hax-lock");
            });
          } // was true, not locked
          else if (!_this3.lock && propName === "lock" && oldValue) {
              _pageBreakManager.pageBreakManager.elementsBetween(_this3).forEach(function (el) {
                el.removeAttribute("data-hax-lock");
              });
            } // update CE menu when these change if it is around


          if (_this3._ceMenu && ["locked", "parent", "published"].includes(propName)) {
            _this3._updateHAXCEMenu();
          } // fire event for reaction so we can update state elsewhere


          if (["title", "parent", "path"].includes(propName)) {
            window.dispatchEvent(new CustomEvent("page-break-change", {
              composed: true,
              bubbles: true,
              cancelable: true,
              detail: {
                value: _this3
              }
            }));
          } // while the most common, only do these when we have a target


          if (_this3.breakType === "node" && _this3.target) {
            if (propName === "title" && _this3[propName]) {
              // change title text to match title if updated but delay
              // to avoid input spamming as this could generate a lot of change records
              // but don't just set it as it would generate another change record
              if (_this3.__moUpdate) {
                // skips the update of innerText to match
                _this3.__moUpdate = false;
              } else if (_this3.title != _this3.target.innerText) {
                _this3.target.innerText = _this3.title;
              }
            } // the magic a11y rewriter


            if (!_this3._haxState && propName === "depth" && _this3.depth >= 0) {
              _pageBreakManager.pageBreakManager.elementsBetween(_this3, "page-break", "h1,h2,h3,h4,h5,h6").forEach(function (el) {
                var tagNumber = (el.getAttribute("data-original-level") ? new Number(el.getAttribute("data-original-level").replace("H", "")) : new Number(el.tagName.replace("H", ""))) + _this3.depth;
                tagNumber = tagNumber > 6 ? 6 : tagNumber;
                var newH = document.createElement("h".concat(tagNumber));
                newH.setAttribute("data-original-level", el.tagName);

                for (var i = 0, l = el.attributes.length; i < l; ++i) {
                  newH.setAttribute(el.attributes.item(i).nodeName, el.attributes.item(i).nodeValue);
                }

                newH.innerHTML = el.innerHTML;

                _this3.setupTargetData(newH);

                el.parentNode.replaceChild(newH, el);
              });
            } // hax state is a special case bc we want to edit in whats saved
            // not what's interpretted


            if (propName === "_haxState" && oldValue !== undefined) {
              if (_this3._haxState) {
                _pageBreakManager.pageBreakManager.elementsBetween(_this3, "page-break", "h1,h2,h3,h4,h5,h6").forEach(function (el) {
                  if (el.getAttribute("data-original-level")) {
                    var tagNumber = new Number(el.getAttribute("data-original-level").replace("H", ""));
                    var newH = document.createElement("h".concat(tagNumber));

                    for (var i = 0, l = el.attributes.length; i < l; ++i) {
                      newH.setAttribute(el.attributes.item(i).nodeName, el.attributes.item(i).nodeValue);
                    }

                    newH.innerHTML = el.innerHTML;
                    el.parentNode.replaceChild(newH, el);

                    _this3.setupTargetData(newH);
                  }
                });
              } else {
                _pageBreakManager.pageBreakManager.elementsBetween(_this3, "page-break", "h1,h2,h3,h4,h5,h6").forEach(function (el) {
                  var tagNumber = (el.getAttribute("data-original-level") ? new Number(el.getAttribute("data-original-level").replace("H", "")) : new Number(el.tagName.replace("H", ""))) + _this3.depth;
                  tagNumber = tagNumber > 6 ? 6 : tagNumber;
                  var newH = document.createElement("h".concat(tagNumber));
                  newH.setAttribute("data-original-level", el.tagName);

                  for (var i = 0, l = el.attributes.length; i < l; ++i) {
                    newH.setAttribute(el.attributes.item(i).nodeName, el.attributes.item(i).nodeValue);
                  }

                  newH.innerHTML = el.innerHTML;
                  el.parentNode.replaceChild(newH, el);

                  _this3.setupTargetData(newH);
                });
              }
            }
          } // we only support haxcms break types when using haxcms
          // this setting will be enforced by the system itself and no human
          // will have the option of doing this setting


          if (_this3.breakType === "haxcms" && propName === "title" && _this3[propName] && window.HAXCMS) {
            // set the title directly in the activeItem in the store
            // while not permanent, this will allow us to update things
            // on the fly and see them reflected
            window.HAXCMS.requestAvailability().store.activeItem.title = _this3.title;
          } // allow for haxcms page style association to allow users to edit the
          // current page's details


          if (propName === "breakType") {
            var iconPath;

            if (_this3[propName] === "node") {
              iconPath = _simpleIconset.SimpleIconsetStore.getIcon("editor:format-page-break");
              _this3._stateStyle.innerHTML = "\n          :host([data-hax-ray]:hover) .mid::before {\n            content: \"".concat(_this3.t.pageBreak, "\";\n          }");
            } else {
              iconPath = _simpleIconset.SimpleIconsetStore.getIcon("hax:page-details");
              _this3._stateStyle.innerHTML = "\n          :host([data-hax-ray]:hover) .mid::before {\n            content: \"".concat(_this3.t.pageDetails, "\";\n          }");
            } // set background of the tag itself to the icon based on mode


            _this3.style.backgroundImage = "url(\"".concat(iconPath, "\")");
          }
        });
      }
    }, {
      key: "firstUpdated",
      value: function firstUpdated(changedProperties) {
        if (babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak.prototype), "firstUpdated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak.prototype), "firstUpdated", this).call(this, changedProperties);
        }

        this._stateStyle = document.createElement("style");
        this.shadowRoot.appendChild(this._stateStyle);
      }
    }, {
      key: "render",
      value: function render() {
        return (0, _index.html)(_templateObject_941826b0374311ecbe28b7086a8f3f78 || (_templateObject_941826b0374311ecbe28b7086a8f3f78 = babelHelpers.taggedTemplateLiteral(["\n      <a .href=\"", "\" .name=\"#", "\" aria-hidden=\"true\"></a>\n      <hr class=\"mid\" />\n    "])), this.path, this.itemId);
      }
      /**
       * haxProperties integration via file reference
       */

    }, {
      key: "haxHooks",
      value:
      /**
       * haxHooks
       */
      function haxHooks() {
        return {
          editModeChanged: "haxeditModeChanged",
          inlineContextMenu: "haxinlineContextMenu",
          activeElementChanged: "haxactiveElementChanged"
        };
      }
      /**
       * Ensure that if we WERE active and now are not
       * and have a reference to the custom element menu in hax
       * and are the right break type, that we reset these items
       */

    }, {
      key: "haxactiveElementChanged",
      value: function haxactiveElementChanged(element, value) {
        if (this.breakType === "haxcms" && !value && this._ceMenu) {
          this._ceMenu.disableOps = false;
        }
      }
      /**
       * ensure that when we flip states here that we are actively switching the original level var
       */

    }, {
      key: "haxeditModeChanged",
      value: function haxeditModeChanged(value) {
        this._haxState = value;
      }
      /**
       * add buttons when it is in context
       */

    }, {
      key: "haxinlineContextMenu",
      value: function haxinlineContextMenu(ceMenu) {
        this._ceMenu = ceMenu;

        this._updateHAXCEMenu(); // forcibly prevent duplication and deleting of the node controlling the page itself


        if (this.breakType === "haxcms") {
          this._ceMenu.disableOps = true;
        }
      } // update custom element buttons so we can do live status changes

    }, {
      key: "_updateHAXCEMenu",
      value: function _updateHAXCEMenu() {
        this._ceMenu.ceButtons = [{
          icon: this.locked ? "icons:lock" : "icons:lock-open",
          callback: "haxClickInlineLock",
          label: "Toggle Lock"
        }, {
          icon: this.published ? "lrn:view" : "lrn:view-off",
          callback: "haxClickInlinePublished",
          label: "Toggle published"
        }, {
          icon: "editor:format-indent-increase",
          callback: "haxIndentParent",
          label: "Move under parent page break",
          disabled: !_pageBreakManager.pageBreakManager.getParent(this, "indent")
        }, {
          icon: "editor:format-indent-decrease",
          callback: "haxOutdentParent",
          label: "Move out of parent page break",
          disabled: !_pageBreakManager.pageBreakManager.getParent(this, "outdent")
        }];
      }
    }, {
      key: "haxClickInlineLock",
      value: function haxClickInlineLock(e) {
        this.locked = !this.locked;
        return true;
      }
    }, {
      key: "haxClickInlinePublished",
      value: function haxClickInlinePublished(e) {
        this.published = !this.published;
        return true;
      }
    }, {
      key: "haxIndentParent",
      value: function haxIndentParent(e) {
        if (_pageBreakManager.pageBreakManager.getParent(this, "indent")) {
          this.parent = _pageBreakManager.pageBreakManager.getParent(this, "indent").path;
        }

        return true;
      }
    }, {
      key: "haxOutdentItem",
      value: function haxOutdentItem(e) {
        if (_pageBreakManager.pageBreakManager.getParent(this, "outdent")) {
          this.parent = _pageBreakManager.pageBreakManager.getParent(this, "outdent").path;
        } else if (this.parent && _pageBreakManager.pageBreakManager.getParent(this, "outdent") === null) {
          this.parent = null;
        }

        return true;
      }
    }], [{
      key: "tag",
      get: function get() {
        return "page-break";
      }
    }, {
      key: "properties",
      get: function get() {
        var props = {};

        if (babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak), "properties", this)) {
          props = babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak), "properties", this);
        }

        return _objectSpread(_objectSpread({}, props), {}, {
          title: {
            type: String,
            reflect: true
          },
          path: {
            type: String
          },
          parent: {
            type: String,
            reflect: true
          },
          published: {
            type: Boolean,
            reflect: true
          },
          locked: {
            type: Boolean,
            reflect: true
          },
          depth: {
            type: Number,
            reflect: true
          },
          itemId: {
            type: String,
            attribute: "item-id",
            reflect: true
          },
          breakType: {
            type: String,
            attribute: "break-type"
          },
          _haxState: {
            type: Boolean
          }
        });
      }
    }, {
      key: "styles",
      get: function get() {
        return [(0, _index.css)(_templateObject2_941826b0374311ecbe28b7086a8f3f78 || (_templateObject2_941826b0374311ecbe28b7086a8f3f78 = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: block;\n          opacity: 0;\n          height: 1px;\n        }\n        :host([data-hax-ray]) {\n          display: block;\n          margin: 20px 0;\n          padding: 20px;\n          opacity: 0.2;\n          background-position: center;\n          background-repeat: no-repeat;\n          transition: all 0.2s linear;\n        }\n        .mid {\n          border: none;\n          border-top: 2px solid #cccccc;\n          overflow: visible;\n          margin: 4px 0 0 0;\n          padding: 0;\n          height: 0;\n        }\n        :host([data-hax-ray]:hover) {\n          opacity: 1;\n        }\n        :host([data-hax-ray]:hover) .mid::before {\n          font-weight: bold;\n          color: #000000;\n          background-color: #ffffff;\n          font-size: 16px;\n          left: calc(50% - 2.5em);\n          top: -16px;\n          position: relative;\n          height: 0;\n          line-height: 36px;\n        }\n      "])))];
      }
    }, {
      key: "haxProperties",
      get: function get() {
        return new URL("./lib/page-break.haxProperties.json", meta.url).href;
      }
    }]);
    return PageBreak;
  }((0, _IntersectionObserverMixin.IntersectionObserverMixin)((0, _I18NMixin.I18NMixin)((0, _schemaBehaviors.SchemaBehaviors)(_index.LitElement))));

  _exports.PageBreak = PageBreak;
  customElements.define(PageBreak.tag, PageBreak);
});