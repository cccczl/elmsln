define(["exports", "require", "../../../lit/index.js", "../../simple-fields/lib/simple-fields-upload.js", "../../utils/utils.js", "./hax-store.js", "../../i18n-manager/lib/I18NMixin.js"], function (_exports, _require, _index, _simpleFieldsUpload, _utils, _haxStore, _I18NMixin) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HaxUploadField = void 0;
  _require = _interopRequireWildcard(_require);

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function localStorageGet(name) {
    try {
      return localStorage.getItem(name);
    } catch (e) {
      return false;
    }
  }

  var HaxUploadField = /*#__PURE__*/function (_winEventsElement) {
    babelHelpers.inherits(HaxUploadField, _winEventsElement);

    var _super = _createSuper(HaxUploadField);

    /**
     * HTMLElement life cycle
     */
    function HaxUploadField() {
      var _this;

      babelHelpers.classCallCheck(this, HaxUploadField);
      _this = _super.call(this);
      _this.autocomplete = "on";
      _this.__winEvents = {
        "hax-app-picker-selection": "_haxAppPickerSelection" //TODO

      };
      _this.t = {
        whereUpload: "Where would you like to upload this",
        cantHandle: "Sorry, you don't have a storage location that can handle",
        uploads: "uploads"
      };

      _this.registerLocalization({
        context: babelHelpers.assertThisInitialized(_this),
        namespace: "hax"
      });

      return _this;
    }

    babelHelpers.createClass(HaxUploadField, [{
      key: "_canUpload",
      value: function _canUpload() {
        return !this.__allowUpload && _haxStore.HAXStore;
      }
      /**
       * Respond to uploading a file
       */

    }, {
      key: "_fileAboutToUpload",
      value: function _fileAboutToUpload(e) {
        if (this._canUpload()) {
          // cancel the event so we can jump in
          e.preventDefault();
          e.stopPropagation(); // look for a match as to what gizmo types it supports

          var values = {
            source: e.detail.file.name,
            type: e.detail.file.type
          }; // we have no clue what this is.. let's try and guess..

          var type = _haxStore.HAXStore.guessGizmoType(values); // find targets that support this type


          var targets = _haxStore.HAXStore.getHaxAppStoreTargets(type); // make sure we have targets


          if (targets.length === 1) {
            this._haxAppPickerSelection({
              detail: targets[0]
            });
          } else if (targets.length !== 0) {
            _haxStore.HAXStore.haxAppPicker.presentOptions(targets, type, "".concat(this.t.whereUpload, " ").concat(type, "?"), "app");
          } else if (type === "document" && e.detail.file.type === "application/vnd.openxmlformats-officedocument.wordprocessingml.document") {
            // not sure if this works anywhere else but let's try and trigger here..
            new Promise(function (res, rej) {
              return _require.default(["../../file-system-broker/lib/docx-file-system-broker.js"], res, rej);
            }).then(function () {
              // this will kick off a promise
              window.DOCXFileSystemBroker.requestAvailability().fileToHTML(e.detail.file, "hax-upload");
            });
          } else {
            _haxStore.HAXStore.toast("".concat(this.t.cantHandle, " ").concat(type, " ").concat(this.t.uploads, "!"), 5000);
          }
        } else {
          this.__allowUpload = false;
        }
      }
    }, {
      key: "insertDOCXFileContents",
      value: function insertDOCXFileContents(e) {
        // sanity check for later on if we ever use this
        if (e.detail.name === "hax-upload") {
          var div = document.createElement("div");
          div.innerHTML = e.detail.value;
          var slot = false;

          if (_haxStore.HAXStore.activeNode.hasAttribute("slot")) {
            slot = _haxStore.HAXStore.activeNode.getAttribute("slot");
          }

          for (var i = div.children.length - 1; i > 0; i--) {
            if (slot) {
              div.children[i].setAttribute("slot", slot);
            }

            _haxStore.HAXStore.activeNode.parentNode.insertBefore(div.children[i], _haxStore.HAXStore.activeNode.nextSibling);
          }
        }
      }
    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(HaxUploadField.prototype), "connectedCallback", this).call(this);
        window.addEventListener("docx-file-system-data", this.insertDOCXFileContents.bind(this));
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.removeEventListener("docx-file-system-data", this.insertDOCXFileContents.bind(this));
        babelHelpers.get(babelHelpers.getPrototypeOf(HaxUploadField.prototype), "disconnectedCallback", this).call(this);
      }
      /**
       * Event for an app being selected from a picker
       * This happens when multiple upload targets support the given type
       */

    }, {
      key: "_haxAppPickerSelection",
      value: function _haxAppPickerSelection(e) {
        // details for where to upload the file
        var connection = e.detail.connection;
        this.__appUsed = e.detail;
        this.shadowRoot.querySelector("#fileupload").method = connection.operations.add.method;
        var requestEndPoint = connection.protocol + "://" + connection.url; // ensure we build a url correctly

        if (requestEndPoint.substr(requestEndPoint.length - 1) != "/") {
          requestEndPoint += "/";
        } // support local end point modification


        if (babelHelpers.typeof(connection.operations.add.endPoint) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          requestEndPoint += connection.operations.add.endPoint;
        } // implementation specific tweaks to talk to things like HAXcms and other CMSs
        // that have per load token based authentication


        if (_haxStore.HAXStore.connectionRewrites.appendUploadEndPoint != null) {
          requestEndPoint += "?" + _haxStore.HAXStore.connectionRewrites.appendUploadEndPoint;
        }

        if (_haxStore.HAXStore.connectionRewrites.appendJwt != null) {
          requestEndPoint += "&" + _haxStore.HAXStore.connectionRewrites.appendJwt + "=" + localStorageGet(_haxStore.HAXStore.connectionRewrites.appendJwt);
        }

        this.shadowRoot.querySelector("#fileupload").headers = connection.headers;
        this.shadowRoot.querySelector("#fileupload").target = requestEndPoint; // invoke file uploading...

        this.__allowUpload = true;
        this.shadowRoot.querySelector("#fileupload").uploadFiles();
      }
      /**
       * Respond to successful file upload, now inject url into url field and
       * do a gizmo guess from there!
       */

    }, {
      key: "_fileUploadResponse",
      value: function _fileUploadResponse(e) {
        // convert response to object
        var response = JSON.parse(e.detail.xhr.response); // access the app that did the upload

        var map = this.__appUsed.connection.operations.add.resultMap;
        var data = {};
        var item = {}; // look for the items element to draw our data from at its root

        if (babelHelpers.typeof(this._resolveObjectPath(map.item, response)) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          data = this._resolveObjectPath(map.item, response);
        }

        item.type = map.defaultGizmoType; // pull in prop matches

        for (var prop in map.gizmo) {
          item[prop] = this._resolveObjectPath(map.gizmo[prop], data);
        } // another sanity check, if we don't have a url but have a source bind that too


        if (babelHelpers.typeof(item.url) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(item.source) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          item.url = item.source;
        } // gizmo type is also supported in the mapping element itself
        // Think an asset management backend as opposed to a specific
        // type of asset like video. If the item coming across can
        // effectively check what kind of gizmo is required for it
        // to work then we need to support that asset declaring the
        // gizmo type needed


        if (babelHelpers.typeof(map.gizmo.type) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          item.type = this._resolveObjectPath(map.gizmo.type, data);
        } // set the value of the url which will update our URL and notify


        this.shadowRoot.querySelector("#url").value = item.url; //TODO need a way to get suggestedResources from HAXStore and then add uploaded resource
        //this.suggestedResources['item.url'] = ''; or this.suggestedResources['item.url'] = { name, icon, type, preview };
      }
    }], [{
      key: "tag",
      get: function get() {
        return "hax-upload-field";
      }
    }]);
    return HaxUploadField;
  }((0, _utils.winEventsElement)((0, _I18NMixin.I18NMixin)(_simpleFieldsUpload.SimpleFieldsUpload)));

  _exports.HaxUploadField = HaxUploadField;
  customElements.define(HaxUploadField.tag, HaxUploadField);
});